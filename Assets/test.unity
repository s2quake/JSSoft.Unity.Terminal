%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!29 &1
OcclusionCullingSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_OcclusionBakeSettings:
    smallestOccluder: 5
    smallestHole: 0.25
    backfaceThreshold: 100
  m_SceneGUID: 00000000000000000000000000000000
  m_OcclusionCullingData: {fileID: 0}
--- !u!104 &2
RenderSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 9
  m_Fog: 0
  m_FogColor: {r: 0.5, g: 0.5, b: 0.5, a: 1}
  m_FogMode: 3
  m_FogDensity: 0.01
  m_LinearFogStart: 0
  m_LinearFogEnd: 300
  m_AmbientSkyColor: {r: 0.212, g: 0.227, b: 0.259, a: 1}
  m_AmbientEquatorColor: {r: 0.114, g: 0.125, b: 0.133, a: 1}
  m_AmbientGroundColor: {r: 0.047, g: 0.043, b: 0.035, a: 1}
  m_AmbientIntensity: 1
  m_AmbientMode: 0
  m_SubtractiveShadowColor: {r: 0.42, g: 0.478, b: 0.627, a: 1}
  m_SkyboxMaterial: {fileID: 10304, guid: 0000000000000000f000000000000000, type: 0}
  m_HaloStrength: 0.5
  m_FlareStrength: 1
  m_FlareFadeSpeed: 3
  m_HaloTexture: {fileID: 0}
  m_SpotCookie: {fileID: 10001, guid: 0000000000000000e000000000000000, type: 0}
  m_DefaultReflectionMode: 0
  m_DefaultReflectionResolution: 128
  m_ReflectionBounces: 1
  m_ReflectionIntensity: 1
  m_CustomReflection: {fileID: 0}
  m_Sun: {fileID: 0}
  m_IndirectSpecularColor: {r: 0, g: 0, b: 0, a: 1}
  m_UseRadianceAmbientProbe: 0
--- !u!157 &3
LightmapSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 11
  m_GIWorkflowMode: 1
  m_GISettings:
    serializedVersion: 2
    m_BounceScale: 1
    m_IndirectOutputScale: 1
    m_AlbedoBoost: 1
    m_EnvironmentLightingMode: 0
    m_EnableBakedLightmaps: 1
    m_EnableRealtimeLightmaps: 1
  m_LightmapEditorSettings:
    serializedVersion: 12
    m_Resolution: 2
    m_BakeResolution: 40
    m_AtlasSize: 1024
    m_AO: 0
    m_AOMaxDistance: 1
    m_CompAOExponent: 1
    m_CompAOExponentDirect: 0
    m_ExtractAmbientOcclusion: 0
    m_Padding: 2
    m_LightmapParameters: {fileID: 0}
    m_LightmapsBakeMode: 1
    m_TextureCompression: 1
    m_FinalGather: 0
    m_FinalGatherFiltering: 1
    m_FinalGatherRayCount: 256
    m_ReflectionCompression: 2
    m_MixedBakeMode: 2
    m_BakeBackend: 1
    m_PVRSampling: 1
    m_PVRDirectSampleCount: 32
    m_PVRSampleCount: 512
    m_PVRBounces: 2
    m_PVREnvironmentSampleCount: 256
    m_PVREnvironmentReferencePointCount: 2048
    m_PVRFilteringMode: 1
    m_PVRDenoiserTypeDirect: 1
    m_PVRDenoiserTypeIndirect: 1
    m_PVRDenoiserTypeAO: 1
    m_PVRFilterTypeDirect: 0
    m_PVRFilterTypeIndirect: 0
    m_PVRFilterTypeAO: 0
    m_PVREnvironmentMIS: 1
    m_PVRCulling: 1
    m_PVRFilteringGaussRadiusDirect: 1
    m_PVRFilteringGaussRadiusIndirect: 5
    m_PVRFilteringGaussRadiusAO: 2
    m_PVRFilteringAtrousPositionSigmaDirect: 0.5
    m_PVRFilteringAtrousPositionSigmaIndirect: 2
    m_PVRFilteringAtrousPositionSigmaAO: 1
    m_ExportTrainingData: 0
    m_TrainingDataDestination: TrainingData
  m_LightingDataAsset: {fileID: 0}
  m_UseShadowmask: 1
--- !u!196 &4
NavMeshSettings:
  serializedVersion: 2
  m_ObjectHideFlags: 0
  m_BuildSettings:
    serializedVersion: 2
    agentTypeID: 0
    agentRadius: 0.5
    agentHeight: 2
    agentSlope: 45
    agentClimb: 0.4
    ledgeDropHeight: 0
    maxJumpAcrossDistance: 0
    minRegionArea: 2
    manualCellSize: 0
    cellSize: 0.16666667
    manualTileSize: 0
    tileSize: 256
    accuratePlacement: 0
    debug:
      m_Flags: 0
  m_NavMeshData: {fileID: 0}
--- !u!1 &311462594
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 311462598}
  - component: {fileID: 311462597}
  - component: {fileID: 311462596}
  - component: {fileID: 311462595}
  m_Layer: 5
  m_Name: Canvas
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!114 &311462595
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 311462594}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: dc42784cf147c0c48a680349fa168899, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_IgnoreReversedGraphics: 1
  m_BlockingObjects: 0
  m_BlockingMask:
    serializedVersion: 2
    m_Bits: 4294967295
--- !u!114 &311462596
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 311462594}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 0cd44c1031e13a943bb63640046fad76, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_UiScaleMode: 0
  m_ReferencePixelsPerUnit: 100
  m_ScaleFactor: 1
  m_ReferenceResolution: {x: 800, y: 600}
  m_ScreenMatchMode: 0
  m_MatchWidthOrHeight: 0
  m_PhysicalUnit: 3
  m_FallbackScreenDPI: 96
  m_DefaultSpriteDPI: 96
  m_DynamicPixelsPerUnit: 1
--- !u!223 &311462597
Canvas:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 311462594}
  m_Enabled: 1
  serializedVersion: 3
  m_RenderMode: 0
  m_Camera: {fileID: 0}
  m_PlaneDistance: 100
  m_PixelPerfect: 0
  m_ReceivesEvents: 1
  m_OverrideSorting: 0
  m_OverridePixelPerfect: 0
  m_SortingBucketNormalizedSize: 0
  m_AdditionalShaderChannelsFlag: 25
  m_SortingLayerID: 0
  m_SortingOrder: 0
  m_TargetDisplay: 0
--- !u!224 &311462598
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 311462594}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 0, y: 0, z: 0}
  m_Children:
  - {fileID: 1914692748}
  m_Father: {fileID: 0}
  m_RootOrder: 2
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0, y: 0}
  m_AnchorMax: {x: 0, y: 0}
  m_AnchoredPosition: {x: 0, y: 0}
  m_SizeDelta: {x: 0, y: 0}
  m_Pivot: {x: 0, y: 0}
--- !u!1 &459233088
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 459233089}
  - component: {fileID: 459233091}
  - component: {fileID: 459233090}
  m_Layer: 5
  m_Name: GameObject (5)
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &459233089
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 459233088}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 745717591}
  m_RootOrder: 5
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0, y: 0}
  m_AnchorMax: {x: 1, y: 1}
  m_AnchoredPosition: {x: 0, y: 0}
  m_SizeDelta: {x: 0, y: 0}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!114 &459233090
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 459233088}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: be35723111c364561ad66ec0fb2088fe, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 0}
  m_Color: {r: 1, g: 1, b: 1, a: 1}
  m_RaycastTarget: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  fontAsset: {fileID: 11400000, guid: 3e2d08f512b954dce81863c9d84b7db4, type: 2}
  grid: {fileID: 1914692749}
--- !u!222 &459233091
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 459233088}
  m_CullTransparentMesh: 0
--- !u!21 &478319185
Material:
  serializedVersion: 6
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_Name: TextMeshPro/Bitmap
  m_Shader: {fileID: 4800000, guid: 128e987d567d4e2c824d754223b3f3b0, type: 3}
  m_ShaderKeywords: 
  m_LightmapFlags: 4
  m_EnableInstancingVariants: 0
  m_DoubleSidedGI: 0
  m_CustomRenderQueue: -1
  stringTagMap: {}
  disabledShaderPasses: []
  m_SavedProperties:
    serializedVersion: 3
    m_TexEnvs:
    - _FaceTex:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _MainTex:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    m_Floats:
    - _ColorMask: 15
    - _MaskSoftnessX: 0
    - _MaskSoftnessY: 0
    - _Stencil: 0
    - _StencilComp: 8
    - _StencilOp: 0
    - _StencilReadMask: 255
    - _StencilWriteMask: 255
    - _VertexOffsetX: 0
    - _VertexOffsetY: 0
    m_Colors:
    - _ClipRect: {r: -32767, g: -32767, b: 32767, a: 32767}
    - _FaceColor: {r: 1, g: 1, b: 1, a: 1}
--- !u!1 &548016343
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 548016344}
  - component: {fileID: 548016346}
  - component: {fileID: 548016345}
  m_Layer: 5
  m_Name: GameObject (4)
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &548016344
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 548016343}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 745717591}
  m_RootOrder: 4
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0, y: 0}
  m_AnchorMax: {x: 1, y: 1}
  m_AnchoredPosition: {x: 0, y: 0}
  m_SizeDelta: {x: 0, y: 0}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!114 &548016345
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 548016343}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: be35723111c364561ad66ec0fb2088fe, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 0}
  m_Color: {r: 1, g: 1, b: 1, a: 1}
  m_RaycastTarget: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  fontAsset: {fileID: 11400000, guid: af7a54341e77143bbbed54d908a9f37b, type: 2}
  grid: {fileID: 1914692749}
--- !u!222 &548016346
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 548016343}
  m_CullTransparentMesh: 0
--- !u!1 &566498932
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 566498933}
  - component: {fileID: 566498935}
  - component: {fileID: 566498934}
  m_Layer: 5
  m_Name: Handle
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &566498933
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 566498932}
  m_LocalRotation: {x: -0, y: -0, z: -0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 1189208569}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0, y: 0}
  m_AnchorMax: {x: 0, y: 0}
  m_AnchoredPosition: {x: 0, y: 0}
  m_SizeDelta: {x: 20, y: 20}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!114 &566498934
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 566498932}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: fe87c0e1cc204ed48ad3b37840f39efc, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 0}
  m_Color: {r: 0.54509807, g: 0.54509807, b: 0.54509807, a: 0}
  m_RaycastTarget: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  m_Sprite: {fileID: 10905, guid: 0000000000000000f000000000000000, type: 0}
  m_Type: 1
  m_PreserveAspect: 0
  m_FillCenter: 1
  m_FillMethod: 4
  m_FillAmount: 1
  m_FillClockwise: 1
  m_FillOrigin: 0
  m_UseSpriteMesh: 0
  m_PixelsPerUnitMultiplier: 0.5
--- !u!222 &566498935
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 566498932}
  m_CullTransparentMesh: 0
--- !u!21 &683031487
Material:
  serializedVersion: 6
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_Name: TextMeshPro/Bitmap
  m_Shader: {fileID: 4800000, guid: 128e987d567d4e2c824d754223b3f3b0, type: 3}
  m_ShaderKeywords: 
  m_LightmapFlags: 4
  m_EnableInstancingVariants: 0
  m_DoubleSidedGI: 0
  m_CustomRenderQueue: -1
  stringTagMap: {}
  disabledShaderPasses: []
  m_SavedProperties:
    serializedVersion: 3
    m_TexEnvs:
    - _FaceTex:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    - _MainTex:
        m_Texture: {fileID: 0}
        m_Scale: {x: 1, y: 1}
        m_Offset: {x: 0, y: 0}
    m_Floats:
    - _ColorMask: 15
    - _MaskSoftnessX: 0
    - _MaskSoftnessY: 0
    - _Stencil: 0
    - _StencilComp: 8
    - _StencilOp: 0
    - _StencilReadMask: 255
    - _StencilWriteMask: 255
    - _VertexOffsetX: 0
    - _VertexOffsetY: 0
    m_Colors:
    - _ClipRect: {r: -32767, g: -32767, b: 32767, a: 32767}
    - _FaceColor: {r: 1, g: 1, b: 1, a: 1}
--- !u!1 &737875553
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 737875555}
  - component: {fileID: 737875554}
  m_Layer: 0
  m_Name: Directional Light
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!108 &737875554
Light:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 737875553}
  m_Enabled: 1
  serializedVersion: 9
  m_Type: 1
  m_Color: {r: 1, g: 0.95686275, b: 0.8392157, a: 1}
  m_Intensity: 1
  m_Range: 10
  m_SpotAngle: 30
  m_InnerSpotAngle: 21.80208
  m_CookieSize: 10
  m_Shadows:
    m_Type: 2
    m_Resolution: -1
    m_CustomResolution: -1
    m_Strength: 1
    m_Bias: 0.05
    m_NormalBias: 0.4
    m_NearPlane: 0.2
    m_CullingMatrixOverride:
      e00: 1
      e01: 0
      e02: 0
      e03: 0
      e10: 0
      e11: 1
      e12: 0
      e13: 0
      e20: 0
      e21: 0
      e22: 1
      e23: 0
      e30: 0
      e31: 0
      e32: 0
      e33: 1
    m_UseCullingMatrixOverride: 0
  m_Cookie: {fileID: 0}
  m_DrawHalo: 0
  m_Flare: {fileID: 0}
  m_RenderMode: 0
  m_CullingMask:
    serializedVersion: 2
    m_Bits: 4294967295
  m_RenderingLayerMask: 1
  m_Lightmapping: 4
  m_LightShadowCasterMode: 0
  m_AreaSize: {x: 1, y: 1}
  m_BounceIntensity: 1
  m_ColorTemperature: 6570
  m_UseColorTemperature: 0
  m_BoundingSphereOverride: {x: 0, y: 0, z: 0, w: 0}
  m_UseBoundingSphereOverride: 0
  m_ShadowRadius: 0
  m_ShadowAngle: 0
--- !u!4 &737875555
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 737875553}
  m_LocalRotation: {x: 0.40821788, y: -0.23456968, z: 0.10938163, w: 0.8754261}
  m_LocalPosition: {x: 0, y: 3, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 0}
  m_RootOrder: 1
  m_LocalEulerAnglesHint: {x: 50, y: -30, z: 0}
--- !u!1 &745717590
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 745717591}
  - component: {fileID: 745717593}
  - component: {fileID: 745717592}
  m_Layer: 5
  m_Name: TerminalForeground
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &745717591
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 745717590}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children:
  - {fileID: 1847478502}
  - {fileID: 2050778123}
  - {fileID: 967481279}
  - {fileID: 2101046976}
  - {fileID: 548016344}
  - {fileID: 459233089}
  m_Father: {fileID: 1914692748}
  m_RootOrder: 2
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0, y: 0}
  m_AnchorMax: {x: 1, y: 1}
  m_AnchoredPosition: {x: 0, y: 0}
  m_SizeDelta: {x: 0, y: 0}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!114 &745717592
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 745717590}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: be35723111c364561ad66ec0fb2088fe, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 0}
  m_Color: {r: 1, g: 1, b: 1, a: 1}
  m_RaycastTarget: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  fontAsset: {fileID: 11400000, guid: 32e57321513a94fafbed115139352789, type: 2}
  grid: {fileID: 1914692749}
--- !u!222 &745717593
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 745717590}
  m_CullTransparentMesh: 0
--- !u!21 &904512970
Material:
  serializedVersion: 6
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_Name: Unlit/Color
  m_Shader: {fileID: 10755, guid: 0000000000000000f000000000000000, type: 0}
  m_ShaderKeywords: 
  m_LightmapFlags: 4
  m_EnableInstancingVariants: 0
  m_DoubleSidedGI: 0
  m_CustomRenderQueue: -1
  stringTagMap: {}
  disabledShaderPasses: []
  m_SavedProperties:
    serializedVersion: 3
    m_TexEnvs: []
    m_Floats: []
    m_Colors:
    - _Color: {r: 0, g: 0, b: 0, a: 1}
--- !u!1 &967481278
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 967481279}
  - component: {fileID: 967481281}
  - component: {fileID: 967481280}
  m_Layer: 5
  m_Name: GameObject (2)
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &967481279
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 967481278}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 745717591}
  m_RootOrder: 2
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0, y: 0}
  m_AnchorMax: {x: 1, y: 1}
  m_AnchoredPosition: {x: 0, y: 0}
  m_SizeDelta: {x: 0, y: 0}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!114 &967481280
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 967481278}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: be35723111c364561ad66ec0fb2088fe, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 0}
  m_Color: {r: 1, g: 1, b: 1, a: 1}
  m_RaycastTarget: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  fontAsset: {fileID: 11400000, guid: 6314a074a21ce4bc6ad81dd932940bbf, type: 2}
  grid: {fileID: 1914692749}
--- !u!222 &967481281
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 967481278}
  m_CullTransparentMesh: 0
--- !u!1 &1064685953
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 1064685956}
  - component: {fileID: 1064685955}
  - component: {fileID: 1064685954}
  m_Layer: 0
  m_Name: Main Camera
  m_TagString: MainCamera
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!81 &1064685954
AudioListener:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1064685953}
  m_Enabled: 1
--- !u!20 &1064685955
Camera:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1064685953}
  m_Enabled: 1
  serializedVersion: 2
  m_ClearFlags: 2
  m_BackGroundColor: {r: 1, g: 1, b: 1, a: 0}
  m_projectionMatrixMode: 1
  m_GateFitMode: 2
  m_FOVAxisMode: 0
  m_SensorSize: {x: 36, y: 24}
  m_LensShift: {x: 0, y: 0}
  m_FocalLength: 50
  m_NormalizedViewPortRect:
    serializedVersion: 2
    x: 0
    y: 0
    width: 1
    height: 1
  near clip plane: 0.3
  far clip plane: 1000
  field of view: 60
  orthographic: 0
  orthographic size: 5
  m_Depth: -1
  m_CullingMask:
    serializedVersion: 2
    m_Bits: 4294967295
  m_RenderingPath: -1
  m_TargetTexture: {fileID: 0}
  m_TargetDisplay: 0
  m_TargetEye: 3
  m_HDR: 1
  m_AllowMSAA: 1
  m_AllowDynamicResolution: 0
  m_ForceIntoRT: 0
  m_OcclusionCulling: 1
  m_StereoConvergence: 10
  m_StereoSeparation: 0.022
--- !u!4 &1064685956
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1064685953}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 1, z: -10}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 0}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
--- !u!1 &1189208568
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 1189208569}
  m_Layer: 5
  m_Name: Sliding Area
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &1189208569
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1189208568}
  m_LocalRotation: {x: -0, y: -0, z: -0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children:
  - {fileID: 566498933}
  m_Father: {fileID: 1684732832}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0, y: 0}
  m_AnchorMax: {x: 1, y: 1}
  m_AnchoredPosition: {x: 0, y: 0}
  m_SizeDelta: {x: -20, y: -20}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!1 &1250052426
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 1250052427}
  - component: {fileID: 1250052429}
  - component: {fileID: 1250052428}
  m_Layer: 5
  m_Name: TerminalCursor
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &1250052427
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1250052426}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 1914692748}
  m_RootOrder: 1
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0, y: 0}
  m_AnchorMax: {x: 1, y: 1}
  m_AnchoredPosition: {x: 0, y: 0}
  m_SizeDelta: {x: 0, y: 0}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!114 &1250052428
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1250052426}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 283e6a0a03ab0477eaeff767ea73c85f, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 478319185}
  m_Color: {r: 1, g: 1, b: 1, a: 1}
  m_RaycastTarget: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  grid: {fileID: 1914692749}
  cursorLeft: 7
  cursorTop: 24
  isVisible: 1
  isFocused: 0
--- !u!222 &1250052429
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1250052426}
  m_CullTransparentMesh: 0
--- !u!1 &1326564169
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 1326564172}
  - component: {fileID: 1326564171}
  - component: {fileID: 1326564170}
  m_Layer: 0
  m_Name: EventSystem
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!114 &1326564170
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1326564169}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 4f231c4fb786f3946a6b90b886c48677, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_HorizontalAxis: Horizontal
  m_VerticalAxis: Vertical
  m_SubmitButton: Submit
  m_CancelButton: Cancel
  m_InputActionsPerSecond: 10
  m_RepeatDelay: 0.5
  m_ForceModuleActive: 0
--- !u!114 &1326564171
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1326564169}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 76c392e42b5098c458856cdf6ecaaaa1, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_FirstSelected: {fileID: 0}
  m_sendNavigationEvents: 1
  m_DragThreshold: 10
--- !u!4 &1326564172
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1326564169}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 0}
  m_RootOrder: 3
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
--- !u!1 &1684732831
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 1684732832}
  - component: {fileID: 1684732835}
  - component: {fileID: 1684732834}
  - component: {fileID: 1684732836}
  - component: {fileID: 1684732833}
  m_Layer: 5
  m_Name: TerminalScrollbar
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &1684732832
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1684732831}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children:
  - {fileID: 1189208569}
  m_Father: {fileID: 1914692748}
  m_RootOrder: 4
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 1, y: 0}
  m_AnchorMax: {x: 1, y: 1}
  m_AnchoredPosition: {x: -12, y: 0}
  m_SizeDelta: {x: 20, y: 0}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!114 &1684732833
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1684732831}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 4a761e435bcd646f6be7a698a3f7a535, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  grid: {fileID: 1914692749}
  useFade: 1
  watingTime: 1
  fadingTime: 0.25
--- !u!114 &1684732834
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1684732831}
  m_Enabled: 0
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: fe87c0e1cc204ed48ad3b37840f39efc, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 0}
  m_Color: {r: 0.54509807, g: 0.54509807, b: 0.54509807, a: 1}
  m_RaycastTarget: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  m_Sprite: {fileID: 10907, guid: 0000000000000000f000000000000000, type: 0}
  m_Type: 1
  m_PreserveAspect: 0
  m_FillCenter: 1
  m_FillMethod: 4
  m_FillAmount: 1
  m_FillClockwise: 1
  m_FillOrigin: 0
  m_UseSpriteMesh: 0
  m_PixelsPerUnitMultiplier: 1
--- !u!222 &1684732835
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1684732831}
  m_CullTransparentMesh: 0
--- !u!114 &1684732836
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1684732831}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: c40668b22dcdb4ddca84c8a2ab9446ac, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Navigation:
    m_Mode: 3
    m_SelectOnUp: {fileID: 0}
    m_SelectOnDown: {fileID: 0}
    m_SelectOnLeft: {fileID: 0}
    m_SelectOnRight: {fileID: 0}
  m_Transition: 1
  m_Colors:
    m_NormalColor: {r: 1, g: 1, b: 1, a: 1}
    m_HighlightedColor: {r: 0.9607843, g: 0.9607843, b: 0.9607843, a: 1}
    m_PressedColor: {r: 0.78431374, g: 0.78431374, b: 0.78431374, a: 1}
    m_SelectedColor: {r: 0.9607843, g: 0.9607843, b: 0.9607843, a: 1}
    m_DisabledColor: {r: 0.78431374, g: 0.78431374, b: 0.78431374, a: 0.5019608}
    m_ColorMultiplier: 1
    m_FadeDuration: 0.1
  m_SpriteState:
    m_HighlightedSprite: {fileID: 0}
    m_PressedSprite: {fileID: 0}
    m_SelectedSprite: {fileID: 0}
    m_DisabledSprite: {fileID: 0}
  m_AnimationTriggers:
    m_NormalTrigger: Normal
    m_HighlightedTrigger: Highlighted
    m_PressedTrigger: Pressed
    m_SelectedTrigger: Selected
    m_DisabledTrigger: Disabled
  m_Interactable: 1
  m_TargetGraphic: {fileID: 1684732834}
  m_HandleRect: {fileID: 566498933}
  m_Direction: 3
  m_Value: 1
  m_Size: 0.0254842
  m_NumberOfSteps: 0
  m_OnValueChanged:
    m_PersistentCalls:
      m_Calls: []
--- !u!1 &1847478501
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 1847478502}
  - component: {fileID: 1847478504}
  - component: {fileID: 1847478503}
  m_Layer: 5
  m_Name: GameObject
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &1847478502
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1847478501}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 745717591}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0, y: 0}
  m_AnchorMax: {x: 1, y: 1}
  m_AnchoredPosition: {x: 0, y: 0}
  m_SizeDelta: {x: 0, y: 0}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!114 &1847478503
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1847478501}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: be35723111c364561ad66ec0fb2088fe, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 0}
  m_Color: {r: 1, g: 1, b: 1, a: 1}
  m_RaycastTarget: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  fontAsset: {fileID: 11400000, guid: 4fe5f6c3ccd0b4095a5d77998bcce368, type: 2}
  grid: {fileID: 1914692749}
--- !u!222 &1847478504
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1847478501}
  m_CullTransparentMesh: 0
--- !u!1 &1858257000
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 1858257001}
  - component: {fileID: 1858257003}
  - component: {fileID: 1858257002}
  m_Layer: 5
  m_Name: TerminalComposition
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &1858257001
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1858257000}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 1914692748}
  m_RootOrder: 3
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0, y: 0}
  m_AnchorMax: {x: 1, y: 1}
  m_AnchoredPosition: {x: 0, y: 0}
  m_SizeDelta: {x: 0, y: 0}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!114 &1858257002
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1858257000}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: db045bc67a55b42fcba20e98deda08db, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 904512970}
  m_Color: {r: 0, g: 0, b: 0, a: 1}
  m_RaycastTarget: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  text: 
  fontColor: {r: 1, g: 1, b: 1, a: 1}
  grid: {fileID: 1914692749}
  columnIndex: 7
  rowIndex: 24
--- !u!222 &1858257003
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1858257000}
  m_CullTransparentMesh: 0
--- !u!1 &1914692747
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 1914692748}
  - component: {fileID: 1914692751}
  - component: {fileID: 1914692750}
  - component: {fileID: 1914692749}
  m_Layer: 5
  m_Name: Terminal
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &1914692748
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1914692747}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children:
  - {fileID: 1949075381}
  - {fileID: 1250052427}
  - {fileID: 745717591}
  - {fileID: 1858257001}
  - {fileID: 1684732832}
  m_Father: {fileID: 311462598}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0, y: 0}
  m_AnchorMax: {x: 1, y: 1}
  m_AnchoredPosition: {x: 0, y: 0}
  m_SizeDelta: {x: 0, y: 0}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!114 &1914692749
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1914692747}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 2972e3d36c4284a08815a62f49463a7f, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 0}
  m_Color: {r: 0.09019608, g: 0.09019608, b: 0.09019608, a: 1}
  m_RaycastTarget: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  fontAsset: {fileID: 11400000, guid: 32e57321513a94fafbed115139352789, type: 2}
  text: "//Released under the MIT License.\n//\n//Copyright (c) 2018 Ntreev Soft co.,
    Ltd.\n//\n//Permission is hereby granted, free of charge, to any person obtaining
    a copy of this software and associated \n//documentation files (the \"Software\"),
    to deal in the Software without restriction, including without limitation the
    \n//rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
    sell copies of the Software, and to permit \n//persons to whom the Software is
    furnished to do so, subject to the following conditions:\n//\n//The above copyright
    notice and this permission notice shall be included in all copies or substantial
    portions of the \n//Software.\n//\n//THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT
    WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE \n//WARRANTIES
    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
    EVENT SHALL THE AUTHORS OR \n//COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
    OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR \n//OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    THE SOFTWARE.\n\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing
    System.Linq;\nusing System.Security;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing
    System.Threading;\n\nnamespace Ntreev.Library.Commands\n{\n    public class Terminal\n
    \   {\n        private static ConsoleKeyInfo cancelKeyInfo = new ConsoleKeyInfo('\\u0003',
    ConsoleKey.C, false, false, true);\n        private static readonly Dictionary<char,
    int> charToWidth = new Dictionary<char, int>(char.MaxValue);\n        private
    static int bufferWidth = 80;\n\n        private readonly Dictionary<ConsoleKeyInfo,
    Action> actionMaps = new Dictionary<ConsoleKeyInfo, Action>();\n        private
    readonly List<string> histories = new List<string>();\n        private readonly
    List<string> completions = new List<string>();\n\n        private int y = Console.CursorTop;\n
    \       private int width = Console.BufferWidth;\n        private int fullIndex;\n
    \       private int start = 0;\n        private int historyIndex;\n        private
    string fullText;\n        private string inputText;\n        private string completion
    = string.Empty;\n        private TextWriter writer;\n        private bool isHidden;\n
    \       private bool treatControlCAsInput;\n        private bool isCancellationRequested;\n\n
    \       static Terminal()\n        {\n            {\n                var name
    = $\"{typeof(Terminal).Namespace}.{PlatformID.Win32NT}.dat\";\n                using
    (var stream = typeof(Terminal).Assembly.GetManifestResourceStream(name))\n                {\n
    \                   var buffer = new byte[stream.Length];\n                    stream.Read(buffer,
    0, buffer.Length);\n\n                    for (var i = char.MinValue; i < char.MaxValue;
    i++)\n                    {\n                        charToWidth.Add(i, buffer[i]);\n
    \                   }\n                }\n            }\n        }\n\n        public
    static bool IsOutputRedirected\n        {\n            get\n            {\n#if
    !NET35\n                return Console.IsOutputRedirected;\n#else\n                return
    true;\n#endif\n\n            }\n        }\n        public static bool IsInputRedirected\n
    \       {\n            get\n            {\n#if !NET35\n                return
    Console.IsInputRedirected;\n#else\n                return true;\n#endif\n            }\n
    \       }\n\n        public static int GetLength(string text)\n        {\n            var
    length = 0;\n            foreach (var item in text)\n            {\n                length
    += charToWidth[item];\n            }\n            return length;\n        }\n\n
    \       public Terminal()\n        {\n            if (Terminal.IsInputRedirected
    == true)\n                throw new Exception(\"Terminal cannot use. Console.IsInputRedirected
    must be false\");\n            this.actionMaps.Add(new ConsoleKeyInfo('\\u001b',
    ConsoleKey.Escape, false, false, false), this.Clear);\n            if (Environment.OSVersion.Platform
    == PlatformID.Unix)\n            {\n                this.actionMaps.Add(new ConsoleKeyInfo('\\0',
    ConsoleKey.Backspace, false, false, false), this.Backspace);\n            }\n
    \           else\n            {\n                this.actionMaps.Add(new ConsoleKeyInfo('\\b',
    ConsoleKey.Backspace, false, false, false), this.Backspace);\n            }\n
    \           this.actionMaps.Add(new ConsoleKeyInfo('\\0', ConsoleKey.Delete, false,
    false, false), this.Delete);\n            this.actionMaps.Add(new ConsoleKeyInfo('\\0',
    ConsoleKey.Home, false, false, false), this.Home);\n            this.actionMaps.Add(new
    ConsoleKeyInfo('\\0', ConsoleKey.Home, false, false, true), this.DeleteToHome);\n
    \           this.actionMaps.Add(new ConsoleKeyInfo('\\0', ConsoleKey.End, false,
    false, false), this.End);\n            this.actionMaps.Add(new ConsoleKeyInfo('\\0',
    ConsoleKey.End, false, false, true), this.DeleteToEnd);\n            this.actionMaps.Add(new
    ConsoleKeyInfo('\\0', ConsoleKey.UpArrow, false, false, false), this.PrevHistory);\n
    \           this.actionMaps.Add(new ConsoleKeyInfo('\\0', ConsoleKey.DownArrow,
    false, false, false), this.NextHistory);\n            this.actionMaps.Add(new
    ConsoleKeyInfo('\\0', ConsoleKey.LeftArrow, false, false, false), this.Left);\n
    \           this.actionMaps.Add(new ConsoleKeyInfo('\\0', ConsoleKey.RightArrow,
    false, false, false), this.Right);\n            this.actionMaps.Add(new ConsoleKeyInfo('\\t',
    ConsoleKey.Tab, false, false, false), this.NextCompletion);\n            this.actionMaps.Add(new
    ConsoleKeyInfo('\\t', ConsoleKey.Tab, true, false, false), this.PrevCompletion);\n
    \       }\n\n        public long? ReadLong(string prompt)\n        {\n            var
    result = this.ReadNumber(prompt, null, i => long.TryParse(i, out long v));\n            if
    (result is long)\n            {\n                return (long)result;\n            }\n
    \           return null;\n        }\n\n        public long? ReadLong(string prompt,
    long defaultValue)\n        {\n            var result = this.ReadNumber(prompt,
    defaultValue, i => long.TryParse(i, out long v));\n            if (result is long)\n
    \           {\n                return (long)result;\n            }\n            return
    null;\n        }\n\n        public double? ReadDouble(string prompt)\n        {\n
    \           var result = this.ReadNumber(prompt, null, i => double.TryParse(i,
    out double v));\n            if (result is double)\n            {\n                return
    (double)result;\n            }\n            return null;\n        }\n\n        public
    double? ReadDouble(string prompt, double defaultValue)\n        {\n            var
    result = this.ReadNumber(prompt, defaultValue, i => double.TryParse(i, out double
    v));\n            if (result is double)\n            {\n                return
    (double)result;\n            }\n            return null;\n        }\n\n        public
    string ReadString(string prompt)\n        {\n            return ReadString(prompt,
    string.Empty);\n        }\n\n        public string ReadString(string prompt, bool
    isHidden)\n        {\n            return this.ReadString(prompt, string.Empty,
    isHidden);\n        }\n\n        public string ReadString(string prompt, string
    defaultText)\n        {\n            return this.ReadString(prompt, defaultText,
    false);\n        }\n\n        public string ReadString(string prompt, string defaultText,
    bool isHidden)\n        {\n            this.Initialize(prompt, defaultText, isHidden);\n\n
    \           try\n            {\n                return ReadLineImpl(i => true,
    false);\n            }\n            finally\n            {\n                this.Release();\n
    \           }\n        }\n\n        public SecureString ReadSecureString(string
    prompt)\n        {\n            var text = this.ReadString(prompt, true);\n            var
    secureString = new SecureString();\n            foreach (var item in text)\n            {\n
    \               secureString.AppendChar(item);\n            }\n            return
    secureString;\n        }\n\n        public ConsoleKey ReadKey(string prompt, params
    ConsoleKey[] filters)\n        {\n            this.Initialize(prompt, string.Empty,
    false);\n            try\n            {\n                return ReadKeyImpl(filters);\n
    \           }\n            finally\n            {\n                this.Release();\n
    \           }\n        }\n\n        public void NextHistory()\n        {\n            if
    (this.historyIndex + 1 < this.histories.Count)\n            {\n                var
    text = this.histories[this.historyIndex + 1];\n                this.ClearText();\n
    \               this.InsertText(text);\n                this.SetInputText();\n
    \               this.historyIndex++;\n            }\n        }\n\n        public
    void PrevHistory()\n        {\n            if (this.historyIndex > 0)\n            {\n
    \               var text = this.histories[this.historyIndex - 1];\n                this.ClearText();\n
    \               this.InsertText(text);\n                this.SetInputText();\n
    \               this.historyIndex--;\n            }\n            else if (this.histories.Count
    == 1)\n            {\n                var text = this.histories[0];\n                this.ClearText();\n
    \               this.InsertText(text);\n                this.SetInputText();\n
    \               this.historyIndex = 0;\n            }\n        }\n\n        public
    IList<string> Histories\n        {\n            get { return this.histories; }\n
    \       }\n\n        public IList<string> Completions\n        {\n            get
    { return this.completions; }\n        }\n\n        public void Cancel()\n        {\n
    \           this.isCancellationRequested = true;\n        }\n\n        public
    void Clear()\n        {\n            lock (LockedObject)\n            {\n                using
    (TerminalCursorVisible.Set(false))\n                {\n                    this.ClearText();\n
    \                   this.SetInputText();\n                }\n            }\n        }\n\n
    \       public void Delete()\n        {\n            lock (LockedObject)\n            {\n
    \               if (this.Index < this.Length)\n                {\n                    using
    (TerminalCursorVisible.Set(false))\n                    {\n                        this.Index++;\n
    \                       this.Backspace();\n                        this.SetInputText();\n
    \                   }\n                }\n            }\n        }\n\n        public
    void Home()\n        {\n            lock (LockedObject)\n            {\n                using
    (TerminalCursorVisible.Set(false))\n                {\n                    this.Index
    = 0;\n                }\n            }\n        }\n\n        public void End()\n
    \       {\n            lock (LockedObject)\n            {\n                using
    (TerminalCursorVisible.Set(false))\n                {\n                    this.Index
    = this.Length;\n                }\n            }\n        }\n\n        public
    void Left()\n        {\n            lock (LockedObject)\n            {\n                if
    (this.Index > 0)\n                {\n                    using (TerminalCursorVisible.Set(false))\n
    \                   {\n                        this.Index--;\n                        this.SetInputText();\n
    \                   }\n                }\n            }\n        }\n\n        public
    void Right()\n        {\n            lock (LockedObject)\n            {\n                if
    (this.Index + 1 <= this.Length)\n                {\n                    using
    (TerminalCursorVisible.Set(false))\n                    {\n                        this.Index++;\n
    \                       this.SetInputText();\n                    }\n                }\n
    \           }\n        }\n\n        public void Backspace()\n        {\n            lock
    (LockedObject)\n            {\n                if (this.Index > 0)\n                {\n
    \                   using (TerminalCursorVisible.Set(false))\n                    {\n
    \                       this.BackspaceImpl();\n                        this.SetInputText();\n
    \                   }\n                }\n            }\n        }\n\n        public
    void DeleteToEnd()\n        {\n            lock (LockedObject)\n            {\n
    \               using (TerminalCursorVisible.Set(false))\n                {\n
    \                   var index = this.Index;\n                    this.Index =
    this.Length;\n                    while (this.Index > index)\n                    {\n
    \                       this.BackspaceImpl();\n                    }\n                    this.SetInputText();\n
    \               }\n            }\n        }\n\n        public void DeleteToHome()\n
    \       {\n            lock (LockedObject)\n            {\n                using
    (TerminalCursorVisible.Set(false))\n                {\n                    while
    (this.Index > 0)\n                    {\n                        this.BackspaceImpl();\n
    \                   }\n                    this.SetInputText();\n                }\n
    \           }\n        }\n\n        public void NextCompletion()\n        {\n
    \           lock (LockedObject)\n            {\n                this.CompletionImpl(NextCompletion);\n
    \           }\n        }\n\n        public void PrevCompletion()\n        {\n
    \           lock (LockedObject)\n            {\n                this.CompletionImpl(PrevCompletion);\n
    \           }\n        }\n\n        public int Index\n        {\n            get
    { return this.FullIndex - this.start; }\n            set\n            {\n                this.FullIndex
    = value + this.start;\n            }\n        }\n\n        public string Text\n
    \       {\n            get { return this.fullText.Substring(this.start); }\n        }\n\n
    \       public string Prompt\n        {\n            get { return this.fullText.Substring(0,
    this.start); }\n        }\n\n        public bool IsReading\n        {\n            get
    { return this.writer != null; }\n        }\n\n        public int Top\n        {\n
    \           get\n            {\n                if (this.width != Console.BufferWidth)\n
    \               {\n                    this.y = Console.CursorTop - this.fullIndex
    / Console.BufferWidth;\n                    this.width = Console.BufferWidth;\n
    \               }\n                return this.y;\n            }\n            internal
    set\n            {\n                this.y = value;\n            }\n        }\n\n
    \       public bool IsEnabled { get; set; } = true;\n\n        public static int
    BufferWidth\n        {\n            get\n            {\n                if (Terminal.IsOutputRedirected
    == false)\n                    return Console.BufferWidth;\n                return
    bufferWidth;\n            }\n            set\n            {\n                if
    (Terminal.IsOutputRedirected == false)\n                    throw new InvalidOperationException(\"console
    output is redirected.\");\n                if (value <= 0)\n                    throw
    new ArgumentOutOfRangeException();\n                bufferWidth = value;\n            }\n
    \       }\n\n        public static string NextCompletion(string[] completions,
    string text)\n        {\n            completions = completions.OrderBy(item =>
    item)\n                .ToArray();\n            if (completions.Contains(text)
    == true)\n            {\n                for (var i = 0; i < completions.Length;
    i++)\n                {\n                    var r = string.Compare(text, completions[i],
    true);\n                    if (r == 0)\n                    {\n                        if
    (i + 1 < completions.Length)\n                            return completions[i
    + 1];\n                        else\n                            return completions.First();\n
    \                   }\n                }\n            }\n            else\n            {\n
    \               for (var i = 0; i < completions.Length; i++)\n                {\n
    \                   var r = string.Compare(text, completions[i], true);\n                    if
    (r < 0)\n                    {\n                        return completions[i];\n
    \                   }\n                }\n            }\n            return text;\n
    \       }\n\n        public static string PrevCompletion(string[] completions,
    string text)\n        {\n            completions = completions.OrderBy(item =>
    item)\n                .ToArray();\n            if (completions.Contains(text)
    == true)\n            {\n                for (var i = completions.Length - 1;
    i >= 0; i--)\n                {\n                    var r = string.Compare(text,
    completions[i], true);\n                    if (r == 0)\n                    {\n
    \                       if (i - 1 >= 0)\n                            return completions[i
    - 1];\n                        else\n                            return completions.Last();\n
    \                   }\n                }\n            }\n            else\n            {\n
    \               for (var i = completions.Length - 1; i >= 0; i--)\n                {\n
    \                   var r = string.Compare(text, completions[i], true);\n                    if
    (r < 0)\n                    {\n                        return completions[i];\n
    \                   }\n                }\n            }\n            return text;\n
    \       }\n\n        public void SetPrompt(string prompt)\n        {\n            if
    (this.writer == null)\n                throw new Exception(\"prompt can set only
    on read mode.\");\n\n            lock (LockedObject)\n            {\n                using
    (TerminalCursorVisible.Set(false))\n                {\n                    var
    text = this.Text;\n                    var index = this.Index;\n                    this.start
    = 0;\n                    this.Clear();\n                    this.InsertText(prompt);\n
    \                   this.start = this.Index;\n                    this.InsertText(text);\n
    \                   this.Index = index;\n                    this.Draw();\n                }\n
    \           }\n        }\n\n        public event TerminalCancelEventHandler CancelKeyPress;\n\n
    \       public event EventHandler Cancelled;\n\n        protected virtual void
    OnCancelKeyPress(TerminalCancelEventArgs e)\n        {\n            this.CancelKeyPress?.Invoke(this,
    e);\n        }\n\n        protected virtual void OnCancelled(EventArgs e)\n        {\n
    \           this.Cancelled?.Invoke(this, e);\n        }\n\n        protected virtual
    string[] GetCompletion(string[] items, string find)\n        {\n            var
    query = from item in this.completions\n                        where item.StartsWith(find)\n
    \                       select item;\n            return query.ToArray();\n        }\n\n
    \       protected virtual void OnDrawPrompt(TextWriter writer, string prompt)\n
    \       {\n            writer.Write(prompt);\n        }\n\n        protected virtual
    void OnDrawText(TextWriter writer, string text)\n        {\n            writer.Write(text);\n
    \       }\n\n        private int Length\n        {\n            get { return this.fullText.Length
    - this.start; }\n        }\n\n        private void ClearText()\n        {\n            lock
    (LockedObject)\n            {\n                var x = 0;\n                var
    y = this.Top;\n                this.Erase();\n                this.fullText =
    this.fullText.Substring(0, this.start);\n                this.start = this.fullText.Length;\n
    \               this.fullIndex = this.start;\n                this.inputText =
    string.Empty;\n                Console.SetCursorPosition(x, y);\n                this.Draw();\n
    \           }\n        }\n\n        private void InsertText(string text)\n        {\n
    \           if (text == string.Empty)\n                return;\n            lock
    (LockedObject)\n            {\n                this.fullText = this.fullText.Insert(this.fullIndex,
    text);\n                this.fullIndex += text.Length;\n\n                if (this.isHidden
    == true)\n                    return;\n\n                var index = this.fullIndex;\n
    \               var text1 = this.fullText.Substring(this.start);\n\n                using
    (TerminalCursorVisible.Set(false))\n                {\n                    this.FullIndex
    = this.start;\n                    this.OnDrawText(this.writer, text1);\n\n\n
    \                   var x = 0;\n                    var y = this.Top;\n                    NextPosition(this.fullText,
    ref x, ref y);\n\n                    if (y >= Console.BufferHeight)\n                    {\n
    \                       if (Environment.OSVersion.Platform == PlatformID.Unix
    && x == 0)\n                        {\n                            this.writer.WriteLine();\n
    \                       }\n                        this.y--;\n                    }\n
    \                   this.FullIndex = index;\n                }\n            }\n
    \       }\n\n        private void BackspaceImpl()\n        {\n            var
    extraText = this.fullText.Substring(this.fullIndex);\n            var inputIndex
    = this.Index;\n            this.Index = this.Length;\n            if (this.isHidden
    == false)\n            {\n                if (Console.CursorLeft == 0)\n                {\n
    \                   var i = this.Index;\n                    this.Index--;\n                    if
    (Environment.OSVersion.Platform == PlatformID.Unix)\n                        this.writer.Write(\"
    \");\n                    else\n                        this.writer.Write(\"\\0\");\n
    \                   this.Index--;\n                }\n                else\n                {\n
    \                   this.writer.Write(\"\\b\\0\");\n                }\n            }\n\n
    \           this.Index = inputIndex;\n            this.Index--;\n            this.fullText
    = this.fullText.Remove(this.fullIndex, 1);\n            if (this.isHidden == false)\n
    \           {\n                this.writer.Write(extraText);\n            }\n
    \           this.Index = this.Index;\n        }\n\n        private void CompletionImpl(Func<string[],
    string, string> func)\n        {\n            var matches = new List<Match>(CommandStringUtility.MatchCompletion(this.inputText));\n
    \           var find = string.Empty;\n            var prefix = false;\n            var
    postfix = false;\n            var leftText = this.inputText;\n            if (matches.Count
    > 0)\n            {\n                var match = matches.Last();\n                var
    matchText = match.Value;\n                if (matchText.Length > 0 && matchText.First()
    == '\\\"')\n                {\n                    prefix = true;\n                    matchText
    = matchText.Substring(1);\n                }\n                if (matchText.Length
    > 1 && matchText.Last() == '\\\"')\n                {\n                    postfix
    = true;\n                    matchText = matchText.Remove(matchText.Length - 1);\n
    \               }\n                if (matchText == string.Empty || matchText.Trim()
    != string.Empty)\n                {\n                    find = matchText;\n                    matches.RemoveAt(matches.Count
    - 1);\n                    leftText = this.inputText.Remove(match.Index);\n                }\n
    \           }\n\n            var argList = new List<string>();\n            for
    (var i = 0; i < matches.Count; i++)\n            {\n                var matchText
    = CommandStringUtility.TrimQuot(matches[i].Value).Trim();\n                if
    (matchText != string.Empty)\n                    argList.Add(matchText);\n            }\n\n
    \           var completions = this.GetCompletion(argList.ToArray(), find);\n            if
    (completions != null && completions.Any())\n            {\n                this.completion
    = func(completions, this.completion);\n                using (TerminalCursorVisible.Set(false))\n
    \               {\n                    var inputText = this.inputText;\n                    this.ClearText();\n
    \                   if (prefix == true || postfix == true)\n                    {\n
    \                       this.InsertText(leftText + \"\\\"\" + this.completion
    + \"\\\"\");\n                    }\n                    else\n                    {\n
    \                       this.InsertText(leftText + this.completion);\n                    }\n
    \                   this.inputText = inputText;\n                }\n            }\n
    \       }\n\n        private void SetInputText()\n        {\n            this.inputText
    = this.Text.Remove(this.Index, this.Text.Length - this.Index);\n            this.completion
    = string.Empty;\n        }\n\n        private object ReadNumber(string prompt,
    object defaultValue, Func<string, bool> validation)\n        {\n            this.Initialize(prompt,
    $\"{defaultValue}\", false);\n            try\n            {\n                return
    ReadLineImpl(validation, false);\n            }\n            finally\n            {\n
    \               this.Release();\n            }\n        }\n\n        private string
    ReadLineImpl(Func<string, bool> validation, bool recordHistory)\n        {\n            while
    (true)\n            {\n                Thread.Sleep(1);\n                if (this.isCancellationRequested
    == true)\n                    return null;\n                if (this.IsEnabled
    == false)\n                    continue;\n                var keys = this.ReadKeys().ToArray();\n
    \               if (this.isCancellationRequested == true)\n                    return
    null;\n\n                var keyChars = string.Empty;\n                foreach
    (var key in keys)\n                {\n                    if (key == cancelKeyInfo)\n
    \                   {\n                        var args = new TerminalCancelEventArgs(ConsoleSpecialKey.ControlC);\n
    \                       this.OnCancelKeyPress(args);\n                        if
    (args.Cancel == false)\n                        {\n                            this.OnCancelled(EventArgs.Empty);\n
    \                           throw new OperationCanceledException($\"ReadLine is
    cancelled.\");\n                        }\n                    }\n                    else
    if (this.actionMaps.ContainsKey(key) == true)\n                    {\n                        this.actionMaps[key]();\n
    \                   }\n                    else if (key.Key == ConsoleKey.Enter)\n
    \                   {\n                        var text = this.Text;\n                        this.fullText
    = string.Empty;\n                        this.start = 0;\n                        this.fullIndex
    = 0;\n\n                        if (recordHistory == true)\n                        {\n
    \                           if (this.isHidden == false && text != string.Empty)\n
    \                           {\n                                if (this.histories.Contains(text)
    == false)\n                                {\n                                    this.histories.Add(text);\n
    \                                   this.historyIndex = this.histories.Count;\n
    \                               }\n                                else\n                                {\n
    \                                   this.historyIndex = this.histories.LastIndexOf(text)
    + 1;\n                                }\n                            }\n                        }\n
    \                       return text;\n                    }\n                    else
    if (key.KeyChar != '\\0')\n                    {\n                        keyChars
    += key.KeyChar;\n                    }\n                }\n\n                if
    (keyChars != string.Empty && validation(this.Text + keyChars) == true)\n                {\n
    \                   this.InsertText(keyChars);\n                    this.SetInputText();\n
    \               }\n            }\n        }\n\n        private IEnumerable<ConsoleKeyInfo>
    ReadKeys()\n        {\n            while (this.isCancellationRequested == false)\n
    \           {\n                var count = 0;\n                while (true)\n
    \               {\n                    if (Console.KeyAvailable == true)\n                    {\n
    \                       yield return Console.ReadKey(true);\n                    }\n
    \                   else if (count > 1)\n                    {\n                        yield
    break;\n                    }\n                    else\n                    {\n
    \                       Thread.Sleep(1);\n                        count++;\n                    }\n
    \               }\n            }\n        }\n\n        private ConsoleKey ReadKeyImpl(params
    ConsoleKey[] filters)\n        {\n            while (true)\n            {\n                var
    key = Console.ReadKey(true);\n\n                if ((int)key.Modifiers != 0)\n
    \                   continue;\n\n                if (filters.Any() == false ||
    filters.Any(item => item == key.Key) == true)\n                {\n                    this.InsertText(key.Key.ToString());\n
    \                   return key.Key;\n                }\n            }\n        }\n\n
    \       private void Initialize(string prompt, string defaultText, bool isHidden)\n
    \       {\n            lock (LockedObject)\n            {\n                this.writer
    = Console.Out;\n                Console.SetOut(new TerminalTextWriter(Console.Out,
    this, Console.OutputEncoding));\n                this.treatControlCAsInput = Console.TreatControlCAsInput;\n
    \               Console.TreatControlCAsInput = true;\n\n                this.y
    = Console.CursorTop;\n                this.width = Console.BufferWidth;\n                this.start
    = 0;\n                this.isHidden = false;\n                this.fullText =
    prompt;\n                this.fullIndex = prompt.Length;\n                this.OnDrawPrompt(this.writer,
    this.fullText);\n                this.FullIndex = this.fullIndex;\n                this.start
    = this.fullIndex;\n                this.isHidden = isHidden;\n                this.InsertText(defaultText);\n
    \               this.inputText = defaultText;\n            }\n        }\n\n        private
    void Release()\n        {\n            lock (LockedObject)\n            {\n                Console.TreatControlCAsInput
    = this.treatControlCAsInput;\n                Console.SetOut(this.writer);\n                Console.WriteLine();\n
    \               this.writer = null;\n                this.isHidden = false;\n
    \           }\n        }\n\n        internal static void NextPosition(string text,
    ref int x, ref int y)\n        {\n            for (var i = 0; i < text.Length;
    i++)\n            {\n                var ch = text[i];\n                if (ch
    == '\\r')\n                {\n                    x = 0;\n                    continue;\n
    \               }\n                else if (ch == '\\n')\n                {\n
    \                   x = 0;\n                    y++;\n                    continue;\n
    \               }\n\n                var w = charToWidth[ch];\n                if
    (x + w >= Console.BufferWidth)\n                {\n                    x = x +
    w - Console.BufferWidth;\n                    y++;\n                }\n                else\n
    \               {\n                    x += w;\n                }\n            }\n
    \       }\n\n        internal string ReadStringInternal(string prompt)\n        {\n
    \           this.Initialize(prompt, string.Empty, false);\n\n            try\n
    \           {\n                return ReadLineImpl(i => true, true);\n            }\n
    \           finally\n            {\n                this.Release();\n            }\n
    \       }\n\n        internal void Erase()\n        {\n            var x1 = Console.CursorLeft;\n
    \           var y1 = Console.CursorTop;\n\n            var prompt = this.fullText.Substring(0,
    this.start);\n            var text = this.isHidden == true ? string.Empty : this.fullText.Substring(this.start);\n
    \           var x = 0;\n            var y = this.y;\n            NextPosition(prompt,
    ref x, ref y);\n            NextPosition(text, ref x, ref y);\n\n            for
    (var i = this.y; i <= y; i++)\n            {\n                Console.SetCursorPosition(0,
    i);\n                if (Environment.OSVersion.Platform != PlatformID.Unix)\n
    \               {\n                    Console.MoveBufferArea(Console.BufferWidth
    - 1, i, 1, 1, 0, i);\n                    this.writer?.Write($\"\\r{new string('\\0',
    Console.BufferWidth - 1)}\\r\");\n                }\n                else\n                {\n
    \                   this.writer?.Write(\"\\r\" + new string(' ', Console.BufferWidth)
    + \"\\r\");\n                }\n            }\n            Console.SetCursorPosition(x1,
    y1);\n        }\n\n        internal void Draw()\n        {\n            Console.SetCursorPosition(0,
    this.y);\n            var index = this.FullIndex;\n            var y = Console.CursorTop;\n
    \           var x = 0;\n            var prompt = this.fullText.Substring(0, this.start);\n
    \           var text = this.isHidden == true ? string.Empty : this.fullText.Substring(this.start);\n
    \           this.OnDrawPrompt(this.writer, prompt);\n            this.OnDrawText(this.writer,
    text);\n            NextPosition(prompt, ref x, ref y);\n            NextPosition(text,
    ref x, ref y);\n\n            if (y >= Console.BufferHeight)\n            {\n
    \               if (Environment.OSVersion.Platform == PlatformID.Unix && x ==
    0)\n                {\n                    this.writer.WriteLine();\n                }\n
    \               this.y--;\n            }\n            if (index < this.FullIndex)\n
    \               this.FullIndex = index;\n        }\n\n        internal static
    object LockedObject { get; } = new object();\n\n        internal int FullIndex\n
    \       {\n            get { return this.fullIndex; }\n            set\n            {\n
    \               if (value < 0 || value > this.fullText.Length)\n                    throw
    new ArgumentOutOfRangeException(nameof(value));\n\n                this.fullIndex
    = value;\n                if (this.isHidden == false)\n                {\n                    var
    x = 0;\n                    var y = this.Top;\n                    NextPosition(this.fullText.Substring(0,
    value), ref x, ref y);\n                    Console.SetCursorPosition(x, Math.Min(y,
    Console.BufferHeight - 1));\n                }\n            }\n        }\n    }\n}\nc:\\>cls"
  fontColor:
    serializedVersion: 2
    rgba: 4294967295
  selectionColor:
    serializedVersion: 2
    rgba: 4286664497
  cursorColor:
    serializedVersion: 2
    rgba: 4287335307
  visibleIndex: 956
  cursorPosition:
    x: 7
    y: 980
  isCursorVisible: 1
  compositionString: 
--- !u!222 &1914692750
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1914692747}
  m_CullTransparentMesh: 0
--- !u!114 &1914692751
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1914692747}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: fac32324f888247949e70e0eb77d3791, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  outputText: "//Released under the MIT License.\n//\n//Copyright (c) 2018 Ntreev
    Soft co., Ltd.\n//\n//Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated \n//documentation files (the
    \"Software\"), to deal in the Software without restriction, including without
    limitation the \n//rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit \n//persons to whom the Software
    is furnished to do so, subject to the following conditions:\n//\n//The above copyright
    notice and this permission notice shall be included in all copies or substantial
    portions of the \n//Software.\n//\n//THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT
    WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE \n//WARRANTIES
    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
    EVENT SHALL THE AUTHORS OR \n//COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
    OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR \n//OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    THE SOFTWARE.\n\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing
    System.Linq;\nusing System.Security;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing
    System.Threading;\n\nnamespace Ntreev.Library.Commands\n{\n    public class Terminal\n
    \   {\n        private static ConsoleKeyInfo cancelKeyInfo = new ConsoleKeyInfo('\\u0003',
    ConsoleKey.C, false, false, true);\n        private static readonly Dictionary<char,
    int> charToWidth = new Dictionary<char, int>(char.MaxValue);\n        private
    static int bufferWidth = 80;\n\n        private readonly Dictionary<ConsoleKeyInfo,
    Action> actionMaps = new Dictionary<ConsoleKeyInfo, Action>();\n        private
    readonly List<string> histories = new List<string>();\n        private readonly
    List<string> completions = new List<string>();\n\n        private int y = Console.CursorTop;\n
    \       private int width = Console.BufferWidth;\n        private int fullIndex;\n
    \       private int start = 0;\n        private int historyIndex;\n        private
    string fullText;\n        private string inputText;\n        private string completion
    = string.Empty;\n        private TextWriter writer;\n        private bool isHidden;\n
    \       private bool treatControlCAsInput;\n        private bool isCancellationRequested;\n\n
    \       static Terminal()\n        {\n            {\n                var name
    = $\"{typeof(Terminal).Namespace}.{PlatformID.Win32NT}.dat\";\n                using
    (var stream = typeof(Terminal).Assembly.GetManifestResourceStream(name))\n                {\n
    \                   var buffer = new byte[stream.Length];\n                    stream.Read(buffer,
    0, buffer.Length);\n\n                    for (var i = char.MinValue; i < char.MaxValue;
    i++)\n                    {\n                        charToWidth.Add(i, buffer[i]);\n
    \                   }\n                }\n            }\n        }\n\n        public
    static bool IsOutputRedirected\n        {\n            get\n            {\n#if
    !NET35\n                return Console.IsOutputRedirected;\n#else\n                return
    true;\n#endif\n\n            }\n        }\n        public static bool IsInputRedirected\n
    \       {\n            get\n            {\n#if !NET35\n                return
    Console.IsInputRedirected;\n#else\n                return true;\n#endif\n            }\n
    \       }\n\n        public static int GetLength(string text)\n        {\n            var
    length = 0;\n            foreach (var item in text)\n            {\n                length
    += charToWidth[item];\n            }\n            return length;\n        }\n\n
    \       public Terminal()\n        {\n            if (Terminal.IsInputRedirected
    == true)\n                throw new Exception(\"Terminal cannot use. Console.IsInputRedirected
    must be false\");\n            this.actionMaps.Add(new ConsoleKeyInfo('\\u001b',
    ConsoleKey.Escape, false, false, false), this.Clear);\n            if (Environment.OSVersion.Platform
    == PlatformID.Unix)\n            {\n                this.actionMaps.Add(new ConsoleKeyInfo('\\0',
    ConsoleKey.Backspace, false, false, false), this.Backspace);\n            }\n
    \           else\n            {\n                this.actionMaps.Add(new ConsoleKeyInfo('\\b',
    ConsoleKey.Backspace, false, false, false), this.Backspace);\n            }\n
    \           this.actionMaps.Add(new ConsoleKeyInfo('\\0', ConsoleKey.Delete, false,
    false, false), this.Delete);\n            this.actionMaps.Add(new ConsoleKeyInfo('\\0',
    ConsoleKey.Home, false, false, false), this.Home);\n            this.actionMaps.Add(new
    ConsoleKeyInfo('\\0', ConsoleKey.Home, false, false, true), this.DeleteToHome);\n
    \           this.actionMaps.Add(new ConsoleKeyInfo('\\0', ConsoleKey.End, false,
    false, false), this.End);\n            this.actionMaps.Add(new ConsoleKeyInfo('\\0',
    ConsoleKey.End, false, false, true), this.DeleteToEnd);\n            this.actionMaps.Add(new
    ConsoleKeyInfo('\\0', ConsoleKey.UpArrow, false, false, false), this.PrevHistory);\n
    \           this.actionMaps.Add(new ConsoleKeyInfo('\\0', ConsoleKey.DownArrow,
    false, false, false), this.NextHistory);\n            this.actionMaps.Add(new
    ConsoleKeyInfo('\\0', ConsoleKey.LeftArrow, false, false, false), this.Left);\n
    \           this.actionMaps.Add(new ConsoleKeyInfo('\\0', ConsoleKey.RightArrow,
    false, false, false), this.Right);\n            this.actionMaps.Add(new ConsoleKeyInfo('\\t',
    ConsoleKey.Tab, false, false, false), this.NextCompletion);\n            this.actionMaps.Add(new
    ConsoleKeyInfo('\\t', ConsoleKey.Tab, true, false, false), this.PrevCompletion);\n
    \       }\n\n        public long? ReadLong(string prompt)\n        {\n            var
    result = this.ReadNumber(prompt, null, i => long.TryParse(i, out long v));\n            if
    (result is long)\n            {\n                return (long)result;\n            }\n
    \           return null;\n        }\n\n        public long? ReadLong(string prompt,
    long defaultValue)\n        {\n            var result = this.ReadNumber(prompt,
    defaultValue, i => long.TryParse(i, out long v));\n            if (result is long)\n
    \           {\n                return (long)result;\n            }\n            return
    null;\n        }\n\n        public double? ReadDouble(string prompt)\n        {\n
    \           var result = this.ReadNumber(prompt, null, i => double.TryParse(i,
    out double v));\n            if (result is double)\n            {\n                return
    (double)result;\n            }\n            return null;\n        }\n\n        public
    double? ReadDouble(string prompt, double defaultValue)\n        {\n            var
    result = this.ReadNumber(prompt, defaultValue, i => double.TryParse(i, out double
    v));\n            if (result is double)\n            {\n                return
    (double)result;\n            }\n            return null;\n        }\n\n        public
    string ReadString(string prompt)\n        {\n            return ReadString(prompt,
    string.Empty);\n        }\n\n        public string ReadString(string prompt, bool
    isHidden)\n        {\n            return this.ReadString(prompt, string.Empty,
    isHidden);\n        }\n\n        public string ReadString(string prompt, string
    defaultText)\n        {\n            return this.ReadString(prompt, defaultText,
    false);\n        }\n\n        public string ReadString(string prompt, string defaultText,
    bool isHidden)\n        {\n            this.Initialize(prompt, defaultText, isHidden);\n\n
    \           try\n            {\n                return ReadLineImpl(i => true,
    false);\n            }\n            finally\n            {\n                this.Release();\n
    \           }\n        }\n\n        public SecureString ReadSecureString(string
    prompt)\n        {\n            var text = this.ReadString(prompt, true);\n            var
    secureString = new SecureString();\n            foreach (var item in text)\n            {\n
    \               secureString.AppendChar(item);\n            }\n            return
    secureString;\n        }\n\n        public ConsoleKey ReadKey(string prompt, params
    ConsoleKey[] filters)\n        {\n            this.Initialize(prompt, string.Empty,
    false);\n            try\n            {\n                return ReadKeyImpl(filters);\n
    \           }\n            finally\n            {\n                this.Release();\n
    \           }\n        }\n\n        public void NextHistory()\n        {\n            if
    (this.historyIndex + 1 < this.histories.Count)\n            {\n                var
    text = this.histories[this.historyIndex + 1];\n                this.ClearText();\n
    \               this.InsertText(text);\n                this.SetInputText();\n
    \               this.historyIndex++;\n            }\n        }\n\n        public
    void PrevHistory()\n        {\n            if (this.historyIndex > 0)\n            {\n
    \               var text = this.histories[this.historyIndex - 1];\n                this.ClearText();\n
    \               this.InsertText(text);\n                this.SetInputText();\n
    \               this.historyIndex--;\n            }\n            else if (this.histories.Count
    == 1)\n            {\n                var text = this.histories[0];\n                this.ClearText();\n
    \               this.InsertText(text);\n                this.SetInputText();\n
    \               this.historyIndex = 0;\n            }\n        }\n\n        public
    IList<string> Histories\n        {\n            get { return this.histories; }\n
    \       }\n\n        public IList<string> Completions\n        {\n            get
    { return this.completions; }\n        }\n\n        public void Cancel()\n        {\n
    \           this.isCancellationRequested = true;\n        }\n\n        public
    void Clear()\n        {\n            lock (LockedObject)\n            {\n                using
    (TerminalCursorVisible.Set(false))\n                {\n                    this.ClearText();\n
    \                   this.SetInputText();\n                }\n            }\n        }\n\n
    \       public void Delete()\n        {\n            lock (LockedObject)\n            {\n
    \               if (this.Index < this.Length)\n                {\n                    using
    (TerminalCursorVisible.Set(false))\n                    {\n                        this.Index++;\n
    \                       this.Backspace();\n                        this.SetInputText();\n
    \                   }\n                }\n            }\n        }\n\n        public
    void Home()\n        {\n            lock (LockedObject)\n            {\n                using
    (TerminalCursorVisible.Set(false))\n                {\n                    this.Index
    = 0;\n                }\n            }\n        }\n\n        public void End()\n
    \       {\n            lock (LockedObject)\n            {\n                using
    (TerminalCursorVisible.Set(false))\n                {\n                    this.Index
    = this.Length;\n                }\n            }\n        }\n\n        public
    void Left()\n        {\n            lock (LockedObject)\n            {\n                if
    (this.Index > 0)\n                {\n                    using (TerminalCursorVisible.Set(false))\n
    \                   {\n                        this.Index--;\n                        this.SetInputText();\n
    \                   }\n                }\n            }\n        }\n\n        public
    void Right()\n        {\n            lock (LockedObject)\n            {\n                if
    (this.Index + 1 <= this.Length)\n                {\n                    using
    (TerminalCursorVisible.Set(false))\n                    {\n                        this.Index++;\n
    \                       this.SetInputText();\n                    }\n                }\n
    \           }\n        }\n\n        public void Backspace()\n        {\n            lock
    (LockedObject)\n            {\n                if (this.Index > 0)\n                {\n
    \                   using (TerminalCursorVisible.Set(false))\n                    {\n
    \                       this.BackspaceImpl();\n                        this.SetInputText();\n
    \                   }\n                }\n            }\n        }\n\n        public
    void DeleteToEnd()\n        {\n            lock (LockedObject)\n            {\n
    \               using (TerminalCursorVisible.Set(false))\n                {\n
    \                   var index = this.Index;\n                    this.Index =
    this.Length;\n                    while (this.Index > index)\n                    {\n
    \                       this.BackspaceImpl();\n                    }\n                    this.SetInputText();\n
    \               }\n            }\n        }\n\n        public void DeleteToHome()\n
    \       {\n            lock (LockedObject)\n            {\n                using
    (TerminalCursorVisible.Set(false))\n                {\n                    while
    (this.Index > 0)\n                    {\n                        this.BackspaceImpl();\n
    \                   }\n                    this.SetInputText();\n                }\n
    \           }\n        }\n\n        public void NextCompletion()\n        {\n
    \           lock (LockedObject)\n            {\n                this.CompletionImpl(NextCompletion);\n
    \           }\n        }\n\n        public void PrevCompletion()\n        {\n
    \           lock (LockedObject)\n            {\n                this.CompletionImpl(PrevCompletion);\n
    \           }\n        }\n\n        public int Index\n        {\n            get
    { return this.FullIndex - this.start; }\n            set\n            {\n                this.FullIndex
    = value + this.start;\n            }\n        }\n\n        public string Text\n
    \       {\n            get { return this.fullText.Substring(this.start); }\n        }\n\n
    \       public string Prompt\n        {\n            get { return this.fullText.Substring(0,
    this.start); }\n        }\n\n        public bool IsReading\n        {\n            get
    { return this.writer != null; }\n        }\n\n        public int Top\n        {\n
    \           get\n            {\n                if (this.width != Console.BufferWidth)\n
    \               {\n                    this.y = Console.CursorTop - this.fullIndex
    / Console.BufferWidth;\n                    this.width = Console.BufferWidth;\n
    \               }\n                return this.y;\n            }\n            internal
    set\n            {\n                this.y = value;\n            }\n        }\n\n
    \       public bool IsEnabled { get; set; } = true;\n\n        public static int
    BufferWidth\n        {\n            get\n            {\n                if (Terminal.IsOutputRedirected
    == false)\n                    return Console.BufferWidth;\n                return
    bufferWidth;\n            }\n            set\n            {\n                if
    (Terminal.IsOutputRedirected == false)\n                    throw new InvalidOperationException(\"console
    output is redirected.\");\n                if (value <= 0)\n                    throw
    new ArgumentOutOfRangeException();\n                bufferWidth = value;\n            }\n
    \       }\n\n        public static string NextCompletion(string[] completions,
    string text)\n        {\n            completions = completions.OrderBy(item =>
    item)\n                .ToArray();\n            if (completions.Contains(text)
    == true)\n            {\n                for (var i = 0; i < completions.Length;
    i++)\n                {\n                    var r = string.Compare(text, completions[i],
    true);\n                    if (r == 0)\n                    {\n                        if
    (i + 1 < completions.Length)\n                            return completions[i
    + 1];\n                        else\n                            return completions.First();\n
    \                   }\n                }\n            }\n            else\n            {\n
    \               for (var i = 0; i < completions.Length; i++)\n                {\n
    \                   var r = string.Compare(text, completions[i], true);\n                    if
    (r < 0)\n                    {\n                        return completions[i];\n
    \                   }\n                }\n            }\n            return text;\n
    \       }\n\n        public static string PrevCompletion(string[] completions,
    string text)\n        {\n            completions = completions.OrderBy(item =>
    item)\n                .ToArray();\n            if (completions.Contains(text)
    == true)\n            {\n                for (var i = completions.Length - 1;
    i >= 0; i--)\n                {\n                    var r = string.Compare(text,
    completions[i], true);\n                    if (r == 0)\n                    {\n
    \                       if (i - 1 >= 0)\n                            return completions[i
    - 1];\n                        else\n                            return completions.Last();\n
    \                   }\n                }\n            }\n            else\n            {\n
    \               for (var i = completions.Length - 1; i >= 0; i--)\n                {\n
    \                   var r = string.Compare(text, completions[i], true);\n                    if
    (r < 0)\n                    {\n                        return completions[i];\n
    \                   }\n                }\n            }\n            return text;\n
    \       }\n\n        public void SetPrompt(string prompt)\n        {\n            if
    (this.writer == null)\n                throw new Exception(\"prompt can set only
    on read mode.\");\n\n            lock (LockedObject)\n            {\n                using
    (TerminalCursorVisible.Set(false))\n                {\n                    var
    text = this.Text;\n                    var index = this.Index;\n                    this.start
    = 0;\n                    this.Clear();\n                    this.InsertText(prompt);\n
    \                   this.start = this.Index;\n                    this.InsertText(text);\n
    \                   this.Index = index;\n                    this.Draw();\n                }\n
    \           }\n        }\n\n        public event TerminalCancelEventHandler CancelKeyPress;\n\n
    \       public event EventHandler Cancelled;\n\n        protected virtual void
    OnCancelKeyPress(TerminalCancelEventArgs e)\n        {\n            this.CancelKeyPress?.Invoke(this,
    e);\n        }\n\n        protected virtual void OnCancelled(EventArgs e)\n        {\n
    \           this.Cancelled?.Invoke(this, e);\n        }\n\n        protected virtual
    string[] GetCompletion(string[] items, string find)\n        {\n            var
    query = from item in this.completions\n                        where item.StartsWith(find)\n
    \                       select item;\n            return query.ToArray();\n        }\n\n
    \       protected virtual void OnDrawPrompt(TextWriter writer, string prompt)\n
    \       {\n            writer.Write(prompt);\n        }\n\n        protected virtual
    void OnDrawText(TextWriter writer, string text)\n        {\n            writer.Write(text);\n
    \       }\n\n        private int Length\n        {\n            get { return this.fullText.Length
    - this.start; }\n        }\n\n        private void ClearText()\n        {\n            lock
    (LockedObject)\n            {\n                var x = 0;\n                var
    y = this.Top;\n                this.Erase();\n                this.fullText =
    this.fullText.Substring(0, this.start);\n                this.start = this.fullText.Length;\n
    \               this.fullIndex = this.start;\n                this.inputText =
    string.Empty;\n                Console.SetCursorPosition(x, y);\n                this.Draw();\n
    \           }\n        }\n\n        private void InsertText(string text)\n        {\n
    \           if (text == string.Empty)\n                return;\n            lock
    (LockedObject)\n            {\n                this.fullText = this.fullText.Insert(this.fullIndex,
    text);\n                this.fullIndex += text.Length;\n\n                if (this.isHidden
    == true)\n                    return;\n\n                var index = this.fullIndex;\n
    \               var text1 = this.fullText.Substring(this.start);\n\n                using
    (TerminalCursorVisible.Set(false))\n                {\n                    this.FullIndex
    = this.start;\n                    this.OnDrawText(this.writer, text1);\n\n\n
    \                   var x = 0;\n                    var y = this.Top;\n                    NextPosition(this.fullText,
    ref x, ref y);\n\n                    if (y >= Console.BufferHeight)\n                    {\n
    \                       if (Environment.OSVersion.Platform == PlatformID.Unix
    && x == 0)\n                        {\n                            this.writer.WriteLine();\n
    \                       }\n                        this.y--;\n                    }\n
    \                   this.FullIndex = index;\n                }\n            }\n
    \       }\n\n        private void BackspaceImpl()\n        {\n            var
    extraText = this.fullText.Substring(this.fullIndex);\n            var inputIndex
    = this.Index;\n            this.Index = this.Length;\n            if (this.isHidden
    == false)\n            {\n                if (Console.CursorLeft == 0)\n                {\n
    \                   var i = this.Index;\n                    this.Index--;\n                    if
    (Environment.OSVersion.Platform == PlatformID.Unix)\n                        this.writer.Write(\"
    \");\n                    else\n                        this.writer.Write(\"\\0\");\n
    \                   this.Index--;\n                }\n                else\n                {\n
    \                   this.writer.Write(\"\\b\\0\");\n                }\n            }\n\n
    \           this.Index = inputIndex;\n            this.Index--;\n            this.fullText
    = this.fullText.Remove(this.fullIndex, 1);\n            if (this.isHidden == false)\n
    \           {\n                this.writer.Write(extraText);\n            }\n
    \           this.Index = this.Index;\n        }\n\n        private void CompletionImpl(Func<string[],
    string, string> func)\n        {\n            var matches = new List<Match>(CommandStringUtility.MatchCompletion(this.inputText));\n
    \           var find = string.Empty;\n            var prefix = false;\n            var
    postfix = false;\n            var leftText = this.inputText;\n            if (matches.Count
    > 0)\n            {\n                var match = matches.Last();\n                var
    matchText = match.Value;\n                if (matchText.Length > 0 && matchText.First()
    == '\\\"')\n                {\n                    prefix = true;\n                    matchText
    = matchText.Substring(1);\n                }\n                if (matchText.Length
    > 1 && matchText.Last() == '\\\"')\n                {\n                    postfix
    = true;\n                    matchText = matchText.Remove(matchText.Length - 1);\n
    \               }\n                if (matchText == string.Empty || matchText.Trim()
    != string.Empty)\n                {\n                    find = matchText;\n                    matches.RemoveAt(matches.Count
    - 1);\n                    leftText = this.inputText.Remove(match.Index);\n                }\n
    \           }\n\n            var argList = new List<string>();\n            for
    (var i = 0; i < matches.Count; i++)\n            {\n                var matchText
    = CommandStringUtility.TrimQuot(matches[i].Value).Trim();\n                if
    (matchText != string.Empty)\n                    argList.Add(matchText);\n            }\n\n
    \           var completions = this.GetCompletion(argList.ToArray(), find);\n            if
    (completions != null && completions.Any())\n            {\n                this.completion
    = func(completions, this.completion);\n                using (TerminalCursorVisible.Set(false))\n
    \               {\n                    var inputText = this.inputText;\n                    this.ClearText();\n
    \                   if (prefix == true || postfix == true)\n                    {\n
    \                       this.InsertText(leftText + \"\\\"\" + this.completion
    + \"\\\"\");\n                    }\n                    else\n                    {\n
    \                       this.InsertText(leftText + this.completion);\n                    }\n
    \                   this.inputText = inputText;\n                }\n            }\n
    \       }\n\n        private void SetInputText()\n        {\n            this.inputText
    = this.Text.Remove(this.Index, this.Text.Length - this.Index);\n            this.completion
    = string.Empty;\n        }\n\n        private object ReadNumber(string prompt,
    object defaultValue, Func<string, bool> validation)\n        {\n            this.Initialize(prompt,
    $\"{defaultValue}\", false);\n            try\n            {\n                return
    ReadLineImpl(validation, false);\n            }\n            finally\n            {\n
    \               this.Release();\n            }\n        }\n\n        private string
    ReadLineImpl(Func<string, bool> validation, bool recordHistory)\n        {\n            while
    (true)\n            {\n                Thread.Sleep(1);\n                if (this.isCancellationRequested
    == true)\n                    return null;\n                if (this.IsEnabled
    == false)\n                    continue;\n                var keys = this.ReadKeys().ToArray();\n
    \               if (this.isCancellationRequested == true)\n                    return
    null;\n\n                var keyChars = string.Empty;\n                foreach
    (var key in keys)\n                {\n                    if (key == cancelKeyInfo)\n
    \                   {\n                        var args = new TerminalCancelEventArgs(ConsoleSpecialKey.ControlC);\n
    \                       this.OnCancelKeyPress(args);\n                        if
    (args.Cancel == false)\n                        {\n                            this.OnCancelled(EventArgs.Empty);\n
    \                           throw new OperationCanceledException($\"ReadLine is
    cancelled.\");\n                        }\n                    }\n                    else
    if (this.actionMaps.ContainsKey(key) == true)\n                    {\n                        this.actionMaps[key]();\n
    \                   }\n                    else if (key.Key == ConsoleKey.Enter)\n
    \                   {\n                        var text = this.Text;\n                        this.fullText
    = string.Empty;\n                        this.start = 0;\n                        this.fullIndex
    = 0;\n\n                        if (recordHistory == true)\n                        {\n
    \                           if (this.isHidden == false && text != string.Empty)\n
    \                           {\n                                if (this.histories.Contains(text)
    == false)\n                                {\n                                    this.histories.Add(text);\n
    \                                   this.historyIndex = this.histories.Count;\n
    \                               }\n                                else\n                                {\n
    \                                   this.historyIndex = this.histories.LastIndexOf(text)
    + 1;\n                                }\n                            }\n                        }\n
    \                       return text;\n                    }\n                    else
    if (key.KeyChar != '\\0')\n                    {\n                        keyChars
    += key.KeyChar;\n                    }\n                }\n\n                if
    (keyChars != string.Empty && validation(this.Text + keyChars) == true)\n                {\n
    \                   this.InsertText(keyChars);\n                    this.SetInputText();\n
    \               }\n            }\n        }\n\n        private IEnumerable<ConsoleKeyInfo>
    ReadKeys()\n        {\n            while (this.isCancellationRequested == false)\n
    \           {\n                var count = 0;\n                while (true)\n
    \               {\n                    if (Console.KeyAvailable == true)\n                    {\n
    \                       yield return Console.ReadKey(true);\n                    }\n
    \                   else if (count > 1)\n                    {\n                        yield
    break;\n                    }\n                    else\n                    {\n
    \                       Thread.Sleep(1);\n                        count++;\n                    }\n
    \               }\n            }\n        }\n\n        private ConsoleKey ReadKeyImpl(params
    ConsoleKey[] filters)\n        {\n            while (true)\n            {\n                var
    key = Console.ReadKey(true);\n\n                if ((int)key.Modifiers != 0)\n
    \                   continue;\n\n                if (filters.Any() == false ||
    filters.Any(item => item == key.Key) == true)\n                {\n                    this.InsertText(key.Key.ToString());\n
    \                   return key.Key;\n                }\n            }\n        }\n\n
    \       private void Initialize(string prompt, string defaultText, bool isHidden)\n
    \       {\n            lock (LockedObject)\n            {\n                this.writer
    = Console.Out;\n                Console.SetOut(new TerminalTextWriter(Console.Out,
    this, Console.OutputEncoding));\n                this.treatControlCAsInput = Console.TreatControlCAsInput;\n
    \               Console.TreatControlCAsInput = true;\n\n                this.y
    = Console.CursorTop;\n                this.width = Console.BufferWidth;\n                this.start
    = 0;\n                this.isHidden = false;\n                this.fullText =
    prompt;\n                this.fullIndex = prompt.Length;\n                this.OnDrawPrompt(this.writer,
    this.fullText);\n                this.FullIndex = this.fullIndex;\n                this.start
    = this.fullIndex;\n                this.isHidden = isHidden;\n                this.InsertText(defaultText);\n
    \               this.inputText = defaultText;\n            }\n        }\n\n        private
    void Release()\n        {\n            lock (LockedObject)\n            {\n                Console.TreatControlCAsInput
    = this.treatControlCAsInput;\n                Console.SetOut(this.writer);\n                Console.WriteLine();\n
    \               this.writer = null;\n                this.isHidden = false;\n
    \           }\n        }\n\n        internal static void NextPosition(string text,
    ref int x, ref int y)\n        {\n            for (var i = 0; i < text.Length;
    i++)\n            {\n                var ch = text[i];\n                if (ch
    == '\\r')\n                {\n                    x = 0;\n                    continue;\n
    \               }\n                else if (ch == '\\n')\n                {\n
    \                   x = 0;\n                    y++;\n                    continue;\n
    \               }\n\n                var w = charToWidth[ch];\n                if
    (x + w >= Console.BufferWidth)\n                {\n                    x = x +
    w - Console.BufferWidth;\n                    y++;\n                }\n                else\n
    \               {\n                    x += w;\n                }\n            }\n
    \       }\n\n        internal string ReadStringInternal(string prompt)\n        {\n
    \           this.Initialize(prompt, string.Empty, false);\n\n            try\n
    \           {\n                return ReadLineImpl(i => true, true);\n            }\n
    \           finally\n            {\n                this.Release();\n            }\n
    \       }\n\n        internal void Erase()\n        {\n            var x1 = Console.CursorLeft;\n
    \           var y1 = Console.CursorTop;\n\n            var prompt = this.fullText.Substring(0,
    this.start);\n            var text = this.isHidden == true ? string.Empty : this.fullText.Substring(this.start);\n
    \           var x = 0;\n            var y = this.y;\n            NextPosition(prompt,
    ref x, ref y);\n            NextPosition(text, ref x, ref y);\n\n            for
    (var i = this.y; i <= y; i++)\n            {\n                Console.SetCursorPosition(0,
    i);\n                if (Environment.OSVersion.Platform != PlatformID.Unix)\n
    \               {\n                    Console.MoveBufferArea(Console.BufferWidth
    - 1, i, 1, 1, 0, i);\n                    this.writer?.Write($\"\\r{new string('\\0',
    Console.BufferWidth - 1)}\\r\");\n                }\n                else\n                {\n
    \                   this.writer?.Write(\"\\r\" + new string(' ', Console.BufferWidth)
    + \"\\r\");\n                }\n            }\n            Console.SetCursorPosition(x1,
    y1);\n        }\n\n        internal void Draw()\n        {\n            Console.SetCursorPosition(0,
    this.y);\n            var index = this.FullIndex;\n            var y = Console.CursorTop;\n
    \           var x = 0;\n            var prompt = this.fullText.Substring(0, this.start);\n
    \           var text = this.isHidden == true ? string.Empty : this.fullText.Substring(this.start);\n
    \           this.OnDrawPrompt(this.writer, prompt);\n            this.OnDrawText(this.writer,
    text);\n            NextPosition(prompt, ref x, ref y);\n            NextPosition(text,
    ref x, ref y);\n\n            if (y >= Console.BufferHeight)\n            {\n
    \               if (Environment.OSVersion.Platform == PlatformID.Unix && x ==
    0)\n                {\n                    this.writer.WriteLine();\n                }\n
    \               this.y--;\n            }\n            if (index < this.FullIndex)\n
    \               this.FullIndex = index;\n        }\n\n        internal static
    object LockedObject { get; } = new object();\n\n        internal int FullIndex\n
    \       {\n            get { return this.fullIndex; }\n            set\n            {\n
    \               if (value < 0 || value > this.fullText.Length)\n                    throw
    new ArgumentOutOfRangeException(nameof(value));\n\n                this.fullIndex
    = value;\n                if (this.isHidden == false)\n                {\n                    var
    x = 0;\n                    var y = this.Top;\n                    NextPosition(this.fullText.Substring(0,
    value), ref x, ref y);\n                    Console.SetCursorPosition(x, Math.Min(y,
    Console.BufferHeight - 1));\n                }\n            }\n        }\n    }\n}\n"
  prompt: c:\>
  commandText: cls
--- !u!1 &1949075380
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 1949075381}
  - component: {fileID: 1949075383}
  - component: {fileID: 1949075382}
  m_Layer: 5
  m_Name: TerminalBackground
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &1949075381
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1949075380}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 1914692748}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0, y: 0}
  m_AnchorMax: {x: 1, y: 1}
  m_AnchoredPosition: {x: 0, y: 0}
  m_SizeDelta: {x: 0, y: 0}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!114 &1949075382
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1949075380}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: b6bd18a3f9e414890ba0af99286e8afc, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 683031487}
  m_Color: {r: 1, g: 1, b: 1, a: 1}
  m_RaycastTarget: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  grid: {fileID: 1914692749}
--- !u!222 &1949075383
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1949075380}
  m_CullTransparentMesh: 0
--- !u!1 &2050778122
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 2050778123}
  - component: {fileID: 2050778125}
  - component: {fileID: 2050778124}
  m_Layer: 5
  m_Name: GameObject (1)
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &2050778123
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2050778122}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 745717591}
  m_RootOrder: 1
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0, y: 0}
  m_AnchorMax: {x: 1, y: 1}
  m_AnchoredPosition: {x: 0, y: 0}
  m_SizeDelta: {x: 0, y: 0}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!114 &2050778124
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2050778122}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: be35723111c364561ad66ec0fb2088fe, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 0}
  m_Color: {r: 1, g: 1, b: 1, a: 1}
  m_RaycastTarget: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  fontAsset: {fileID: 11400000, guid: 18d71c6546dbd45c29e22d1282bb93f2, type: 2}
  grid: {fileID: 1914692749}
--- !u!222 &2050778125
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2050778122}
  m_CullTransparentMesh: 0
--- !u!1 &2101046975
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 2101046976}
  - component: {fileID: 2101046978}
  - component: {fileID: 2101046977}
  m_Layer: 5
  m_Name: GameObject (3)
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &2101046976
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2101046975}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 745717591}
  m_RootOrder: 3
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0, y: 0}
  m_AnchorMax: {x: 1, y: 1}
  m_AnchoredPosition: {x: 0, y: 0}
  m_SizeDelta: {x: 0, y: 0}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!114 &2101046977
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2101046975}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: be35723111c364561ad66ec0fb2088fe, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 0}
  m_Color: {r: 1, g: 1, b: 1, a: 1}
  m_RaycastTarget: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  fontAsset: {fileID: 11400000, guid: 436690c2fd11c4827becb827403b6f89, type: 2}
  grid: {fileID: 1914692749}
--- !u!222 &2101046978
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2101046975}
  m_CullTransparentMesh: 0
